\hypertarget{le__safe_ref_8h}{}\section{framework/c/inc/le\+\_\+safe\+Ref.h File Reference}
\label{le__safe_ref_8h}\index{framework/c/inc/le\+\_\+safe\+Ref.\+h@{framework/c/inc/le\+\_\+safe\+Ref.\+h}}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct le\+\_\+ref\+\_\+\+Map $\ast$ \hyperlink{le__safe_ref_8h_aaf8fb3412fb840cb50366856affaf69b}{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t}
\item 
typedef struct le\+\_\+ref\+\_\+\+Iter $\ast$ \hyperlink{le__safe_ref_8h_a01b183aea234146b2df8a0ade1451539}{le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{le__safe_ref_8h_aaf8fb3412fb840cb50366856affaf69b}{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t} \hyperlink{le__safe_ref_8h_a85faf3c75723a1af0e1adf720d9c9dca}{le\+\_\+ref\+\_\+\+Create\+Map} (const char $\ast$name, size\+\_\+t max\+Refs)
\item 
void $\ast$ \hyperlink{le__safe_ref_8h_a458597757cbce48e03413b49f52ec240}{le\+\_\+ref\+\_\+\+Create\+Ref} (\hyperlink{le__safe_ref_8h_aaf8fb3412fb840cb50366856affaf69b}{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t} map\+Ref, void $\ast$ptr)
\item 
void $\ast$ \hyperlink{le__safe_ref_8h_a488dddfd579f4a20f39be392c4d7d2e0}{le\+\_\+ref\+\_\+\+Lookup} (\hyperlink{le__safe_ref_8h_aaf8fb3412fb840cb50366856affaf69b}{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t} map\+Ref, void $\ast$safe\+Ref)
\item 
void \hyperlink{le__safe_ref_8h_a438e18b8ace1d4dda3ca5144a27bd424}{le\+\_\+ref\+\_\+\+Delete\+Ref} (\hyperlink{le__safe_ref_8h_aaf8fb3412fb840cb50366856affaf69b}{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t} map\+Ref, void $\ast$safe\+Ref)
\item 
\hyperlink{le__safe_ref_8h_a01b183aea234146b2df8a0ade1451539}{le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t} \hyperlink{le__safe_ref_8h_ab7d9ebce866a3ad49a967e2eb8def2cc}{le\+\_\+ref\+\_\+\+Get\+Iterator} (\hyperlink{le__safe_ref_8h_aaf8fb3412fb840cb50366856affaf69b}{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t} map\+Ref)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{le__safe_ref_8h_ac6304fc29d2ce7c82f5ca3b210931783}{le\+\_\+ref\+\_\+\+Next\+Node} (\hyperlink{le__safe_ref_8h_a01b183aea234146b2df8a0ade1451539}{le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t} iterator\+Ref)
\item 
void const $\ast$ \hyperlink{le__safe_ref_8h_a4028caac51066ef1e2a9988b0f84ab1e}{le\+\_\+ref\+\_\+\+Get\+Safe\+Ref} (\hyperlink{le__safe_ref_8h_a01b183aea234146b2df8a0ade1451539}{le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t} iterator\+Ref)
\item 
void const $\ast$ \hyperlink{le__safe_ref_8h_a9c9273a94a0596516585240908853506}{le\+\_\+ref\+\_\+\+Get\+Value} (\hyperlink{le__safe_ref_8h_a01b183aea234146b2df8a0ade1451539}{le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t} iterator\+Ref)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Legato \hyperlink{c_safeRef}{Safe References A\+P\+I} include file.

Copyright (C) Sierra Wireless Inc. Use of this work is subject to license. 

\subsection{Typedef Documentation}
\hypertarget{le__safe_ref_8h_a01b183aea234146b2df8a0ade1451539}{}\index{le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}!le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t@{le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t}}
\index{le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t@{le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t}!le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}}
\subsubsection[{le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct le\+\_\+ref\+\_\+\+Iter$\ast$ {\bf le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t}}\label{le__safe_ref_8h_a01b183aea234146b2df8a0ade1451539}
Reference to an \char`\"{}iterator\char`\"{} object, used to manage iterating a collection of safe refs. \hypertarget{le__safe_ref_8h_aaf8fb3412fb840cb50366856affaf69b}{}\index{le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}!le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t@{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t}}
\index{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t@{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t}!le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}}
\subsubsection[{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct le\+\_\+ref\+\_\+\+Map$\ast$ {\bf le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t}}\label{le__safe_ref_8h_aaf8fb3412fb840cb50366856affaf69b}
Reference to a \char`\"{}\+Reference Map\char`\"{} object, which stores mappings from Safe References to pointers. 

\subsection{Function Documentation}
\hypertarget{le__safe_ref_8h_a85faf3c75723a1af0e1adf720d9c9dca}{}\index{le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}!le\+\_\+ref\+\_\+\+Create\+Map@{le\+\_\+ref\+\_\+\+Create\+Map}}
\index{le\+\_\+ref\+\_\+\+Create\+Map@{le\+\_\+ref\+\_\+\+Create\+Map}!le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}}
\subsubsection[{le\+\_\+ref\+\_\+\+Create\+Map}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t} le\+\_\+ref\+\_\+\+Create\+Map (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{name, }
\item[{size\+\_\+t}]{max\+Refs}
\end{DoxyParamCaption}
)}\label{le__safe_ref_8h_a85faf3c75723a1af0e1adf720d9c9dca}
Create a Reference Map that can hold mappings from Safe References to pointers.

\begin{DoxyReturn}{Returns}
A reference to the Reference Map object. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em name} & Name of the map (for diagnostics). \\
\hline
\mbox{\tt in}  & {\em max\+Refs} & Maximum number of Safe References expected to be kept in this Reference Map at any one time. \\
\hline
\end{DoxyParams}
\hypertarget{le__safe_ref_8h_a458597757cbce48e03413b49f52ec240}{}\index{le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}!le\+\_\+ref\+\_\+\+Create\+Ref@{le\+\_\+ref\+\_\+\+Create\+Ref}}
\index{le\+\_\+ref\+\_\+\+Create\+Ref@{le\+\_\+ref\+\_\+\+Create\+Ref}!le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}}
\subsubsection[{le\+\_\+ref\+\_\+\+Create\+Ref}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ le\+\_\+ref\+\_\+\+Create\+Ref (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t}}]{map\+Ref, }
\item[{void $\ast$}]{ptr}
\end{DoxyParamCaption}
)}\label{le__safe_ref_8h_a458597757cbce48e03413b49f52ec240}
Creates a Safe Reference, storing a mapping between that reference and a specified pointer for future lookup.

\begin{DoxyReturn}{Returns}
The Safe Reference. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & Reference Map in which the mapping should be kept. \\
\hline
\mbox{\tt in}  & {\em ptr} & Pointer value to which the new Safe Reference will be mapped. \\
\hline
\end{DoxyParams}
\hypertarget{le__safe_ref_8h_a438e18b8ace1d4dda3ca5144a27bd424}{}\index{le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}!le\+\_\+ref\+\_\+\+Delete\+Ref@{le\+\_\+ref\+\_\+\+Delete\+Ref}}
\index{le\+\_\+ref\+\_\+\+Delete\+Ref@{le\+\_\+ref\+\_\+\+Delete\+Ref}!le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}}
\subsubsection[{le\+\_\+ref\+\_\+\+Delete\+Ref}]{\setlength{\rightskip}{0pt plus 5cm}void le\+\_\+ref\+\_\+\+Delete\+Ref (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t}}]{map\+Ref, }
\item[{void $\ast$}]{safe\+Ref}
\end{DoxyParamCaption}
)}\label{le__safe_ref_8h_a438e18b8ace1d4dda3ca5144a27bd424}
Deletes a Safe Reference. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & Reference Map to delete the mapping from. \\
\hline
\mbox{\tt in}  & {\em safe\+Ref} & Safe Reference to be deleted (invalidated). \\
\hline
\end{DoxyParams}
\hypertarget{le__safe_ref_8h_ab7d9ebce866a3ad49a967e2eb8def2cc}{}\index{le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}!le\+\_\+ref\+\_\+\+Get\+Iterator@{le\+\_\+ref\+\_\+\+Get\+Iterator}}
\index{le\+\_\+ref\+\_\+\+Get\+Iterator@{le\+\_\+ref\+\_\+\+Get\+Iterator}!le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}}
\subsubsection[{le\+\_\+ref\+\_\+\+Get\+Iterator}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t} le\+\_\+ref\+\_\+\+Get\+Iterator (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t}}]{map\+Ref}
\end{DoxyParamCaption}
)}\label{le__safe_ref_8h_ab7d9ebce866a3ad49a967e2eb8def2cc}
Gets an interator for step-\/by-\/step iteration over the map. In this mode the iteration is controlled by the calling function using the \hyperlink{le__safe_ref_8h_ac6304fc29d2ce7c82f5ca3b210931783}{le\+\_\+ref\+\_\+\+Next\+Node()} function. There is one iterator per map, and calling this function resets the iterator position to the start of the map. The iterator is not ready for data access until \hyperlink{le__safe_ref_8h_ac6304fc29d2ce7c82f5ca3b210931783}{le\+\_\+ref\+\_\+\+Next\+Node()} has been called at least once.

\begin{DoxyReturn}{Returns}
Returns A reference to a hashmap iterator which is ready for \hyperlink{le__hashmap_8h_a601b7d3e5d92e91e4090d726e5b190ca}{le\+\_\+hashmap\+\_\+\+Next\+Node()} to be called on it. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & Reference to the map. \\
\hline
\end{DoxyParams}
\hypertarget{le__safe_ref_8h_a4028caac51066ef1e2a9988b0f84ab1e}{}\index{le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}!le\+\_\+ref\+\_\+\+Get\+Safe\+Ref@{le\+\_\+ref\+\_\+\+Get\+Safe\+Ref}}
\index{le\+\_\+ref\+\_\+\+Get\+Safe\+Ref@{le\+\_\+ref\+\_\+\+Get\+Safe\+Ref}!le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}}
\subsubsection[{le\+\_\+ref\+\_\+\+Get\+Safe\+Ref}]{\setlength{\rightskip}{0pt plus 5cm}void const$\ast$ le\+\_\+ref\+\_\+\+Get\+Safe\+Ref (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t}}]{iterator\+Ref}
\end{DoxyParamCaption}
)}\label{le__safe_ref_8h_a4028caac51066ef1e2a9988b0f84ab1e}
Retrieves a pointer to the safe ref iterator is currently pointing at. If the iterator has just been initialized and \hyperlink{le__hashmap_8h_a601b7d3e5d92e91e4090d726e5b190ca}{le\+\_\+hashmap\+\_\+\+Next\+Node()} has not been called, or if the iterator has been invalidated then this will return N\+U\+L\+L.

\begin{DoxyReturn}{Returns}
A pointer to the current key, or N\+U\+L\+L if the iterator has been invalidated or is not ready. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iterator\+Ref} & Reference to the iterator. \\
\hline
\end{DoxyParams}
\hypertarget{le__safe_ref_8h_a9c9273a94a0596516585240908853506}{}\index{le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}!le\+\_\+ref\+\_\+\+Get\+Value@{le\+\_\+ref\+\_\+\+Get\+Value}}
\index{le\+\_\+ref\+\_\+\+Get\+Value@{le\+\_\+ref\+\_\+\+Get\+Value}!le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}}
\subsubsection[{le\+\_\+ref\+\_\+\+Get\+Value}]{\setlength{\rightskip}{0pt plus 5cm}void const$\ast$ le\+\_\+ref\+\_\+\+Get\+Value (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t}}]{iterator\+Ref}
\end{DoxyParamCaption}
)}\label{le__safe_ref_8h_a9c9273a94a0596516585240908853506}
Retrieves a pointer to the value which the iterator is currently pointing at. If the iterator has just been initialized and \hyperlink{le__safe_ref_8h_ac6304fc29d2ce7c82f5ca3b210931783}{le\+\_\+ref\+\_\+\+Next\+Node()} has not been called, or if the iterator has been invalidated then this will return N\+U\+L\+L.

\begin{DoxyReturn}{Returns}
A pointer to the current value, or N\+U\+L\+L if the iterator has been invalidated or is not ready. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iterator\+Ref} & Reference to the iterator. \\
\hline
\end{DoxyParams}
\hypertarget{le__safe_ref_8h_a488dddfd579f4a20f39be392c4d7d2e0}{}\index{le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}!le\+\_\+ref\+\_\+\+Lookup@{le\+\_\+ref\+\_\+\+Lookup}}
\index{le\+\_\+ref\+\_\+\+Lookup@{le\+\_\+ref\+\_\+\+Lookup}!le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}}
\subsubsection[{le\+\_\+ref\+\_\+\+Lookup}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ le\+\_\+ref\+\_\+\+Lookup (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t}}]{map\+Ref, }
\item[{void $\ast$}]{safe\+Ref}
\end{DoxyParamCaption}
)}\label{le__safe_ref_8h_a488dddfd579f4a20f39be392c4d7d2e0}
Translates a Safe Reference back to the pointer from when the Safe Reference was created.

\begin{DoxyReturn}{Returns}
Pointer that the Safe Reference maps to, or N\+U\+L\+L if the Safe Reference has been deleted or is invalid. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & Reference Map to do the lookup in. \\
\hline
\mbox{\tt in}  & {\em safe\+Ref} & Safe Reference to be translated into a pointer. \\
\hline
\end{DoxyParams}
\hypertarget{le__safe_ref_8h_ac6304fc29d2ce7c82f5ca3b210931783}{}\index{le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}!le\+\_\+ref\+\_\+\+Next\+Node@{le\+\_\+ref\+\_\+\+Next\+Node}}
\index{le\+\_\+ref\+\_\+\+Next\+Node@{le\+\_\+ref\+\_\+\+Next\+Node}!le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}}
\subsubsection[{le\+\_\+ref\+\_\+\+Next\+Node}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+ref\+\_\+\+Next\+Node (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t}}]{iterator\+Ref}
\end{DoxyParamCaption}
)}\label{le__safe_ref_8h_ac6304fc29d2ce7c82f5ca3b210931783}
Moves the iterator to the next key/value pair in the map. If the hashmap is modified during iteration then this function will return an error.

\begin{DoxyReturn}{Returns}
Returns L\+E\+\_\+\+O\+K unless you go past the end of the map, then returns L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+N\+D. If the iterator has been invalidated by the map changing or you have previously received a L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+N\+D then this returns L\+E\+\_\+\+F\+A\+U\+L\+T. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iterator\+Ref} & Reference to the iterator. \\
\hline
\end{DoxyParams}
