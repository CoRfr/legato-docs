\hypertarget{le__path_iter_8h}{}\section{framework/c/inc/le\+\_\+path\+Iter.h File Reference}
\label{le__path_iter_8h}\index{framework/c/inc/le\+\_\+path\+Iter.\+h@{framework/c/inc/le\+\_\+path\+Iter.\+h}}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct le\+\_\+path\+Iter\+\_\+t $\ast$ \hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{le__path_iter_8h_a73fac1b657b752b17395c66fb1ae324b}{le\+\_\+path\+Iter\+\_\+\+Create} (const char $\ast$path\+Ptr, const char $\ast$separator\+Ptr, const char $\ast$parent\+Spec\+Ptr, const char $\ast$current\+Spec\+Ptr)
\item 
\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{le__path_iter_8h_a35a38b307f9fdc0de82552e96a5a2d1d}{le\+\_\+path\+Iter\+\_\+\+Create\+For\+Unix} (const char $\ast$path\+Ptr)
\item 
\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{le__path_iter_8h_a50349a6c2afa4415d65a6efd443894d3}{le\+\_\+path\+Iter\+\_\+\+Clone} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} original\+Ref)
\item 
void \hyperlink{le__path_iter_8h_a6b57267a2c0db0210aab96c66459f9a1}{le\+\_\+path\+Iter\+\_\+\+Delete} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} iter\+Ref)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{le__path_iter_8h_a586cd64de7f1a6797da3a17896946ee5}{le\+\_\+path\+Iter\+\_\+\+Get\+Separator} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} iter\+Ref, char $\ast$buffer\+Ptr, size\+\_\+t buffer\+Size)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{le__path_iter_8h_af1707a310401be209aeada07f6d0f43f}{le\+\_\+path\+Iter\+\_\+\+Get\+Parent\+Specifier} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} iter\+Ref, char $\ast$buffer\+Ptr, size\+\_\+t buffer\+Size)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{le__path_iter_8h_ac12ea9bbe193fd9239abd10a4b07feba}{le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Specifier} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} iter\+Ref, char $\ast$buffer\+Ptr, size\+\_\+t buffer\+Size)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{le__path_iter_8h_a4a1c39584a779518395b41f957765283}{le\+\_\+path\+Iter\+\_\+\+Get\+Path} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} iter\+Ref, char $\ast$buffer\+Ptr, size\+\_\+t buffer\+Size)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{le__path_iter_8h_af4352480ab3c9ffb09e740f2899d504e}{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Start} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} iter\+Ref)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{le__path_iter_8h_ab1c0b90132171b3f3cf5cfb614329b13}{le\+\_\+path\+Iter\+\_\+\+Go\+To\+End} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} iter\+Ref)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{le__path_iter_8h_ad83a619dcc34ecf03da1859b3da2f57f}{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Next} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} iter\+Ref)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{le__path_iter_8h_a92a740759fe5c3b0a18e39dd8c73466b}{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Prev} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} iter\+Ref)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{le__path_iter_8h_ab00916d853b3a869748b0195cc2a8f11}{le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Node} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} iter\+Ref, char $\ast$buffer\+Ptr, size\+\_\+t buffer\+Size)
\item 
void \hyperlink{le__path_iter_8h_a04be1341536a3e330a815171e7cdbf7a}{le\+\_\+path\+Iter\+\_\+\+Truncate} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} iter\+Ref)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{le__path_iter_8h_ae6aa59696c54d2523009037cc78f9725}{le\+\_\+path\+Iter\+\_\+\+Append} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} iter\+Ref, const char $\ast$path\+Str)
\item 
bool \hyperlink{le__path_iter_8h_a657f779873a2220f463f705298c1399f}{le\+\_\+path\+Iter\+\_\+\+Is\+Absolute} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} iter\+Ref)
\item 
bool \hyperlink{le__path_iter_8h_ab4ceddae696158d04fdbc1802614c5d6}{le\+\_\+path\+Iter\+\_\+\+Is\+Empty} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} iter\+Ref)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Legato \hyperlink{c_pathIter}{Path Iterator A\+P\+I} include file.

Copyright (C) Sierra Wireless Inc. Use of this work is subject to license. license. 

\subsection{Typedef Documentation}
\hypertarget{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{}\index{le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}!le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t@{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}
\index{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t@{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}!le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}}
\subsubsection[{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct le\+\_\+path\+Iter\+\_\+t$\ast$ {\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}\label{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}
Objects of this type are used to iterate and manipulate path strings. 

\subsection{Function Documentation}
\hypertarget{le__path_iter_8h_ae6aa59696c54d2523009037cc78f9725}{}\index{le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}!le\+\_\+path\+Iter\+\_\+\+Append@{le\+\_\+path\+Iter\+\_\+\+Append}}
\index{le\+\_\+path\+Iter\+\_\+\+Append@{le\+\_\+path\+Iter\+\_\+\+Append}!le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}}
\subsubsection[{le\+\_\+path\+Iter\+\_\+\+Append}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Append (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref, }
\item[{const char $\ast$}]{path\+Str}
\end{DoxyParamCaption}
)}\label{le__path_iter_8h_ae6aa59696c54d2523009037cc78f9725}
Take the new string path and combine it with the object\textquotesingle{}s existing path.

\begin{DoxyNote}{Note}
This function looks for the current and parent node strings and treats them specially. So, (assuming defaults,) combining the path \char`\"{}/a/b\char`\"{} with the path \char`\"{}../x\char`\"{} will give you the combined path of\+: \char`\"{}/a/x\char`\"{}.

Appending a non-\/relative path onto an existing path effectivly replaces the current path, for example, appending /a/rooted/path, onto the existing /a/seperate/path will given you the path\+: /a/rooted/path.

This will automatically reset the internal iterator to point at the end of the newly formed path. Also, this function always appends to the end of a path, ignoring the current position of the iterator.
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+O\+K if successful. L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+O\+W if the output buffer is too small for the new string. L\+E\+\_\+\+U\+N\+D\+E\+R\+F\+L\+O\+W if combining the path the new path tries to traverse past the root. For example\+: \char`\"{}/a/b\char`\"{} + \char`\"{}../../../x\char`\"{} will result in L\+E\+\_\+\+U\+N\+D\+E\+R\+F\+L\+O\+W. However if the base path is relative, \char`\"{}a/b\char`\"{}, then the resulting string will be \char`\"{}../x\char`\"{} and a return code of L\+E\+\_\+\+O\+K. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The path object to write to. \\
\hline
\mbox{\tt in}  & {\em path\+Str} & The new path segment to append. \\
\hline
\end{DoxyParams}
\hypertarget{le__path_iter_8h_a50349a6c2afa4415d65a6efd443894d3}{}\index{le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}!le\+\_\+path\+Iter\+\_\+\+Clone@{le\+\_\+path\+Iter\+\_\+\+Clone}}
\index{le\+\_\+path\+Iter\+\_\+\+Clone@{le\+\_\+path\+Iter\+\_\+\+Clone}!le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}}
\subsubsection[{le\+\_\+path\+Iter\+\_\+\+Clone}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Clone (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{original\+Ref}
\end{DoxyParamCaption}
)}\label{le__path_iter_8h_a50349a6c2afa4415d65a6efd443894d3}
Create a clone of an existing path iterator object.

\begin{DoxyReturn}{Returns}
A new path iterator object that is a duplicate of the original one. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em original\+Ref} & The path object to duplicate. \\
\hline
\end{DoxyParams}
\hypertarget{le__path_iter_8h_a73fac1b657b752b17395c66fb1ae324b}{}\index{le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}!le\+\_\+path\+Iter\+\_\+\+Create@{le\+\_\+path\+Iter\+\_\+\+Create}}
\index{le\+\_\+path\+Iter\+\_\+\+Create@{le\+\_\+path\+Iter\+\_\+\+Create}!le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}}
\subsubsection[{le\+\_\+path\+Iter\+\_\+\+Create}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Create (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path\+Ptr, }
\item[{const char $\ast$}]{separator\+Ptr, }
\item[{const char $\ast$}]{parent\+Spec\+Ptr, }
\item[{const char $\ast$}]{current\+Spec\+Ptr}
\end{DoxyParamCaption}
)}\label{le__path_iter_8h_a73fac1b657b752b17395c66fb1ae324b}
Create a new path iterator object. On creation, the default position of the iterator is at the end of the path.

\begin{DoxyReturn}{Returns}
A new path object setup with the given parameters. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path\+Ptr} & Optional. Pointer to the inital path to use. \\
\hline
\mbox{\tt in}  & {\em separator\+Ptr} & Required. Path separator to use. The separator can not be N\+U\+L\+L or empty. \\
\hline
\mbox{\tt in}  & {\em parent\+Spec\+Ptr} & Optional. Used to traverse upwards in a path. Leave as N\+U\+L\+L or empty to not use. This acts like how \char`\"{}..\char`\"{} is used in a filesystem path. \\
\hline
\mbox{\tt in}  & {\em current\+Spec\+Ptr} & Optional. Used to refer to a current node. Much like how a \textquotesingle{}.\textquotesingle{} is used in a filesystem path. \\
\hline
\end{DoxyParams}
\hypertarget{le__path_iter_8h_a35a38b307f9fdc0de82552e96a5a2d1d}{}\index{le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}!le\+\_\+path\+Iter\+\_\+\+Create\+For\+Unix@{le\+\_\+path\+Iter\+\_\+\+Create\+For\+Unix}}
\index{le\+\_\+path\+Iter\+\_\+\+Create\+For\+Unix@{le\+\_\+path\+Iter\+\_\+\+Create\+For\+Unix}!le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}}
\subsubsection[{le\+\_\+path\+Iter\+\_\+\+Create\+For\+Unix}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Create\+For\+Unix (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path\+Ptr}
\end{DoxyParamCaption}
)}\label{le__path_iter_8h_a35a38b307f9fdc0de82552e96a5a2d1d}
Create a new path iterator object that is pre-\/configured for Unix styled paths. On creation, the default position of the iterator is at the end of the path.

The parameters are configured as follows\+:


\begin{DoxyItemize}
\item separator\+: \char`\"{}/\char`\"{}
\item parent\+Spec\+: \char`\"{}..\char`\"{}
\item current\+Spec\+: \char`\"{}.\char`\"{}
\end{DoxyItemize}

\begin{DoxyReturn}{Returns}
A new path iterator object that\textquotesingle{}s ready for iterating on Unix style paths. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path\+Ptr} & Optional. Create an iterator for this path, or start with an empty path. \\
\hline
\end{DoxyParams}
\hypertarget{le__path_iter_8h_a6b57267a2c0db0210aab96c66459f9a1}{}\index{le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}!le\+\_\+path\+Iter\+\_\+\+Delete@{le\+\_\+path\+Iter\+\_\+\+Delete}}
\index{le\+\_\+path\+Iter\+\_\+\+Delete@{le\+\_\+path\+Iter\+\_\+\+Delete}!le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}}
\subsubsection[{le\+\_\+path\+Iter\+\_\+\+Delete}]{\setlength{\rightskip}{0pt plus 5cm}void le\+\_\+path\+Iter\+\_\+\+Delete (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref}
\end{DoxyParamCaption}
)}\label{le__path_iter_8h_a6b57267a2c0db0210aab96c66459f9a1}
Delete an iterator object and free it\textquotesingle{}s memory. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to destroy. \\
\hline
\end{DoxyParams}
\hypertarget{le__path_iter_8h_ab00916d853b3a869748b0195cc2a8f11}{}\index{le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}!le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Node@{le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Node}}
\index{le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Node@{le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Node}!le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}}
\subsubsection[{le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Node}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Node (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref, }
\item[{char $\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t}]{buffer\+Size}
\end{DoxyParamCaption}
)}\label{le__path_iter_8h_ab00916d853b3a869748b0195cc2a8f11}
Get the text for the node the itrator is pointing at.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+O\+K if succesful. L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+O\+W if the buffer\+Ptr is too small to hold the whole string. L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+N\+D if the iterator is at the end of the path. Or if the path is empty, or simply consists of a separator. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to read. \\
\hline
\mbox{\tt out}  & {\em buffer\+Ptr} & The utf-\/8 formatted text buffer to write to. \\
\hline
\mbox{\tt in}  & {\em buffer\+Size} & The size in bytes of the text buffer. \\
\hline
\end{DoxyParams}
\hypertarget{le__path_iter_8h_ac12ea9bbe193fd9239abd10a4b07feba}{}\index{le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}!le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Specifier@{le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Specifier}}
\index{le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Specifier@{le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Specifier}!le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}}
\subsubsection[{le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Specifier}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Specifier (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref, }
\item[{char $\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t}]{buffer\+Size}
\end{DoxyParamCaption}
)}\label{le__path_iter_8h_ac12ea9bbe193fd9239abd10a4b07feba}
Read the iterators string for the current node specifier. For Unix style paths for this is \char`\"{}.\char`\"{}. If an empty string is used, then this is ignored for the purposes of appending and normalizing paths. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to read. \\
\hline
\mbox{\tt out}  & {\em buffer\+Ptr} & The string buffer to write to. \\
\hline
\mbox{\tt in}  & {\em buffer\+Size} & The size of the string buffer being written to. \\
\hline
\end{DoxyParams}
\hypertarget{le__path_iter_8h_af1707a310401be209aeada07f6d0f43f}{}\index{le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}!le\+\_\+path\+Iter\+\_\+\+Get\+Parent\+Specifier@{le\+\_\+path\+Iter\+\_\+\+Get\+Parent\+Specifier}}
\index{le\+\_\+path\+Iter\+\_\+\+Get\+Parent\+Specifier@{le\+\_\+path\+Iter\+\_\+\+Get\+Parent\+Specifier}!le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}}
\subsubsection[{le\+\_\+path\+Iter\+\_\+\+Get\+Parent\+Specifier}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Get\+Parent\+Specifier (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref, }
\item[{char $\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t}]{buffer\+Size}
\end{DoxyParamCaption}
)}\label{le__path_iter_8h_af1707a310401be209aeada07f6d0f43f}
Read the string that represents parent nodes in a path string. By for Unix style paths this is \char`\"{}..\char`\"{}. If an empty string is used, then it is ignored for the purposes of appending and normalizing paths. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to read. \\
\hline
\mbox{\tt out}  & {\em buffer\+Ptr} & The string buffer to write to. \\
\hline
\mbox{\tt in}  & {\em buffer\+Size} & The size of the buffer being written to. \\
\hline
\end{DoxyParams}
\hypertarget{le__path_iter_8h_a4a1c39584a779518395b41f957765283}{}\index{le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}!le\+\_\+path\+Iter\+\_\+\+Get\+Path@{le\+\_\+path\+Iter\+\_\+\+Get\+Path}}
\index{le\+\_\+path\+Iter\+\_\+\+Get\+Path@{le\+\_\+path\+Iter\+\_\+\+Get\+Path}!le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}}
\subsubsection[{le\+\_\+path\+Iter\+\_\+\+Get\+Path}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Get\+Path (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref, }
\item[{char $\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t}]{buffer\+Size}
\end{DoxyParamCaption}
)}\label{le__path_iter_8h_a4a1c39584a779518395b41f957765283}
Get a copy of the path currently contained within the iterator.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+O\+K if the copy is successful. L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+O\+W if the buffer isn\textquotesingle{}t big enough for the path string. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to read. \\
\hline
\mbox{\tt out}  & {\em buffer\+Ptr} & The string buffer to write to. \\
\hline
\mbox{\tt in}  & {\em buffer\+Size} & The size of the buffer being written to. \\
\hline
\end{DoxyParams}
\hypertarget{le__path_iter_8h_a586cd64de7f1a6797da3a17896946ee5}{}\index{le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}!le\+\_\+path\+Iter\+\_\+\+Get\+Separator@{le\+\_\+path\+Iter\+\_\+\+Get\+Separator}}
\index{le\+\_\+path\+Iter\+\_\+\+Get\+Separator@{le\+\_\+path\+Iter\+\_\+\+Get\+Separator}!le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}}
\subsubsection[{le\+\_\+path\+Iter\+\_\+\+Get\+Separator}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Get\+Separator (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref, }
\item[{char $\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t}]{buffer\+Size}
\end{DoxyParamCaption}
)}\label{le__path_iter_8h_a586cd64de7f1a6797da3a17896946ee5}
Read the string that is being used to represent path separators in this iterator object. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to read. \\
\hline
\mbox{\tt out}  & {\em buffer\+Ptr} & The string buffer to write to. \\
\hline
\mbox{\tt in}  & {\em buffer\+Size} & The size of the buffer being written to. \\
\hline
\end{DoxyParams}
\hypertarget{le__path_iter_8h_ab1c0b90132171b3f3cf5cfb614329b13}{}\index{le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}!le\+\_\+path\+Iter\+\_\+\+Go\+To\+End@{le\+\_\+path\+Iter\+\_\+\+Go\+To\+End}}
\index{le\+\_\+path\+Iter\+\_\+\+Go\+To\+End@{le\+\_\+path\+Iter\+\_\+\+Go\+To\+End}!le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}}
\subsubsection[{le\+\_\+path\+Iter\+\_\+\+Go\+To\+End}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Go\+To\+End (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref}
\end{DoxyParamCaption}
)}\label{le__path_iter_8h_ab1c0b90132171b3f3cf5cfb614329b13}
Jump the iterator to the end of the path.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+O\+K if the move was successful. L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+N\+D if the path is empty, or only contains a separator. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to update. \\
\hline
\end{DoxyParams}
\hypertarget{le__path_iter_8h_ad83a619dcc34ecf03da1859b3da2f57f}{}\index{le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}!le\+\_\+path\+Iter\+\_\+\+Go\+To\+Next@{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Next}}
\index{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Next@{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Next}!le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}}
\subsubsection[{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Next}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Go\+To\+Next (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref}
\end{DoxyParamCaption}
)}\label{le__path_iter_8h_ad83a619dcc34ecf03da1859b3da2f57f}
Move to the next node in the path.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+O\+K if the itrator was successful in jumping to the next node. L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+N\+D is returned if there are no more nodes to move to in the path. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to update. \\
\hline
\end{DoxyParams}
\hypertarget{le__path_iter_8h_a92a740759fe5c3b0a18e39dd8c73466b}{}\index{le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}!le\+\_\+path\+Iter\+\_\+\+Go\+To\+Prev@{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Prev}}
\index{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Prev@{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Prev}!le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}}
\subsubsection[{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Prev}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Go\+To\+Prev (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref}
\end{DoxyParamCaption}
)}\label{le__path_iter_8h_a92a740759fe5c3b0a18e39dd8c73466b}
Move to the previous node in the path.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+O\+K if the iterator was successfuly moved, L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+N\+D if there are no prior nodes to move to. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to update. \\
\hline
\end{DoxyParams}
\hypertarget{le__path_iter_8h_af4352480ab3c9ffb09e740f2899d504e}{}\index{le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}!le\+\_\+path\+Iter\+\_\+\+Go\+To\+Start@{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Start}}
\index{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Start@{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Start}!le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}}
\subsubsection[{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Start}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Go\+To\+Start (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref}
\end{DoxyParamCaption}
)}\label{le__path_iter_8h_af4352480ab3c9ffb09e740f2899d504e}
Jump the iterator to the beginning of the path.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+O\+K if the move was successful. L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+N\+D if the path is empty, or only contains a separator. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to update. \\
\hline
\end{DoxyParams}
\hypertarget{le__path_iter_8h_a657f779873a2220f463f705298c1399f}{}\index{le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}!le\+\_\+path\+Iter\+\_\+\+Is\+Absolute@{le\+\_\+path\+Iter\+\_\+\+Is\+Absolute}}
\index{le\+\_\+path\+Iter\+\_\+\+Is\+Absolute@{le\+\_\+path\+Iter\+\_\+\+Is\+Absolute}!le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}}
\subsubsection[{le\+\_\+path\+Iter\+\_\+\+Is\+Absolute}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+path\+Iter\+\_\+\+Is\+Absolute (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref}
\end{DoxyParamCaption}
)}\label{le__path_iter_8h_a657f779873a2220f463f705298c1399f}
Is this an absolute or relative path?

\begin{DoxyReturn}{Returns}
True if the path is absolute, that is that it begins with a separator. False if the path is considered relative. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to read. \\
\hline
\end{DoxyParams}
\hypertarget{le__path_iter_8h_ab4ceddae696158d04fdbc1802614c5d6}{}\index{le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}!le\+\_\+path\+Iter\+\_\+\+Is\+Empty@{le\+\_\+path\+Iter\+\_\+\+Is\+Empty}}
\index{le\+\_\+path\+Iter\+\_\+\+Is\+Empty@{le\+\_\+path\+Iter\+\_\+\+Is\+Empty}!le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}}
\subsubsection[{le\+\_\+path\+Iter\+\_\+\+Is\+Empty}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+path\+Iter\+\_\+\+Is\+Empty (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref}
\end{DoxyParamCaption}
)}\label{le__path_iter_8h_ab4ceddae696158d04fdbc1802614c5d6}
Is the path object holding an empty string?

\begin{DoxyReturn}{Returns}
True if the path is empty, false if not. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em iter\+Ref} & The path object to read. \\
\hline
\end{DoxyParams}
\hypertarget{le__path_iter_8h_a04be1341536a3e330a815171e7cdbf7a}{}\index{le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}!le\+\_\+path\+Iter\+\_\+\+Truncate@{le\+\_\+path\+Iter\+\_\+\+Truncate}}
\index{le\+\_\+path\+Iter\+\_\+\+Truncate@{le\+\_\+path\+Iter\+\_\+\+Truncate}!le\+\_\+path\+Iter.\+h@{le\+\_\+path\+Iter.\+h}}
\subsubsection[{le\+\_\+path\+Iter\+\_\+\+Truncate}]{\setlength{\rightskip}{0pt plus 5cm}void le\+\_\+path\+Iter\+\_\+\+Truncate (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref}
\end{DoxyParamCaption}
)}\label{le__path_iter_8h_a04be1341536a3e330a815171e7cdbf7a}
Truncate the path at the current iterator node. If the iterator is at the beginning of the path, then the whole path is cleared. If the iterator is at the end of the path, then nothing happens.

Once done, then the iterator will be pointing at the new end of the path. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator to update. \\
\hline
\end{DoxyParams}
